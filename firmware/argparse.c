/*
 *   This file was AUTO-GENERATED by pypgmopts.
 *
 *   https://github.com/johndoe31415/pypgmopts
 *
 *   Do not edit it by hand, your changes will be overwritten.
 *
 *   Generated at: 2018-09-02 17:18:05
 */

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include "argparse.h"

enum argparse_option_internal_t {
	ARG_FORCE_SHORT = 'f',
	ARG_VERBOSE_SHORT = 'v',
	ARG_FORCE_LONG = 1000,
	ARG_NO_HARDWARE_LONG = 1001,
	ARG_VERBOSE_LONG = 1002,
	ARG_UNIX_SOCKET_LONG = 1003,
};

bool argparse_parse(int argc, char **argv, argparse_callback_t argument_callback) {
	const char *short_options = "fv";
	struct option long_options[] = {
		{ "force",                            no_argument, 0, ARG_FORCE_LONG },
		{ "no-hardware",                      no_argument, 0, ARG_NO_HARDWARE_LONG },
		{ "verbose",                          no_argument, 0, ARG_VERBOSE_LONG },
		{ "unix_socket",                      required_argument, 0, ARG_UNIX_SOCKET_LONG },
		{ 0 }
	};

	while (true) {
		int optval = getopt_long(argc, argv, short_options, long_options, NULL);
		if (optval == -1) {
			break;
		}
		enum argparse_option_internal_t arg = (enum argparse_option_internal_t)optval;
		switch (arg) {
			case ARG_FORCE_SHORT:
			case ARG_FORCE_LONG:
				if (!argument_callback(ARG_FORCE, optarg)) {
					return false;
				}
				break;

			case ARG_NO_HARDWARE_LONG:
				if (!argument_callback(ARG_NO_HARDWARE, optarg)) {
					return false;
				}
				break;

			case ARG_VERBOSE_SHORT:
			case ARG_VERBOSE_LONG:
				if (!argument_callback(ARG_VERBOSE, optarg)) {
					return false;
				}
				break;

			default:
				return false;
		}
	}

	const int positional_argument_cnt = argc - optind;
	if (positional_argument_cnt < 1) {
		fprintf(stderr, "error: expected a minimum of 1 positional arguments, %d given.\n", positional_argument_cnt);
		return false;
	}
	if (positional_argument_cnt > 1) {
		fprintf(stderr, "error: expected a maximum of 1 positional arguments, %d given.\n", positional_argument_cnt);
		return false;
	}

	int positional_index = optind;
	if (!argument_callback(ARG_UNIX_SOCKET, argv[positional_index++])) {
		return false;
	}

	return true;
}

void argparse_show_syntax(void) {
	fprintf(stderr, "usage: knitserver [-f] [--no-hardware] [-v] socket\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "Brother KH-930 knitting server\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "positional arguments:\n");
	fprintf(stderr, "  socket         UNIX socket that the KnitPi knitting server listens on.\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "optional arguments:\n");
	fprintf(stderr, "  -f, --force    Erase the socket if it already exists.\n");
	fprintf(stderr, "  --no-hardware  Do not initialize actual hardware. Used for debugging\n");
	fprintf(stderr, "                 purposes only.\n");
	fprintf(stderr, "  -v, --verbose  Increase verbosity. Can be specified multiple times.\n");
}

void argparse_parse_or_die(int argc, char **argv, argparse_callback_t argument_callback) {
	if (!argparse_parse(argc, argv, argument_callback)) {
		argparse_show_syntax();
		exit(EXIT_FAILURE);
	}
}

#ifdef __ARGPARSE_MAIN__
/*   gcc -D __ARGPARSE_MAIN__ -O2 -Wall -o argparse argparse.c
*/

static const char *option_enum_to_str(enum argparse_option_t option) {
	switch (option) {
		case ARG_FORCE: return "ARG_FORCE";
		case ARG_NO_HARDWARE: return "ARG_NO_HARDWARE";
		case ARG_VERBOSE: return "ARG_VERBOSE";
		case ARG_UNIX_SOCKET: return "ARG_UNIX_SOCKET";
	}
	return "UNKNOWN";
}

bool arg_print_callback(enum argparse_option_t option, const char *value) {
	fprintf(stderr, "%s = \"%s\"\n", option_enum_to_str(option), value);
	return true;
}

int main(int argc, char **argv) {
	argparse_parse_or_die(argc, argv, arg_print_callback);
	return 0;
}
#endif
